# jamming.run;
#
# execute under AMPL with the command 'include jamming.run;'
#

# reset;

# model player1.mod;
# data initial_p1.dat;
# option solver lgo;
# # option ipopt_options "tol 1e-6";
# option lgo_options "outlev=3";
# solve;

#reset AMPL
reset;

#set solver up
option solver lgo;
option lgo_options "outlev=3";

#define base model
model player1.mod;

#set common data
data;

param varrho := 1;
param alpha := 1;
param sigmasqr := 1;
param eps := 1e-6;
param reg := 1e-3;




# # Write first guess of equilibrium of player 2 to file,
# # so that player 1 can access it:
# close solution_p2.txt;
# print -3.1415 > solution_p2.txt;

# model player1.mod;

# # FOR LOOP
# for {1..5} {
#   # 
#   # Solve player 1 problem with data from player 2:
#   reset data;
#   read y_param_p1 < solution_p2.txt;
#   # Read all other data that player 1 needs here...
#   solve;
#   print 'Player 1:', x_p1;
#   close solution_p1.txt;
#   # Write solution of player 1 problem so that player 2 can access it:
#   print x_p1 > solution_p1.txt;
#   # solve player 2 problem with data from player 1:
#   #
#   # Here we would normally do something like
#   #  reset;
#   #  model player2.mod;
#   # But in our game player 1 and player 2 have the same objectives and constraints,
#   # just different data. So we just pretend that we are player 2 now, using the 
#   # same model as player 1, with data  from player 1 as parameters.
#   reset data;
#   # Note that just 'reset;' does not work, as it deletes all data,
#   # including the index of the for loop.
#   read y_param_p1 < solution_p1.txt;
#   # Read all other data that player 2 needs here...
#   solve;
#   print 'Player 2:', x_p1;
#   close solution_p2.txt;
#   # Write solution of player 2 problem so that player 1 can access it:
#   print x_p1 > solution_p2.txt;
#   #
# } # END FOR